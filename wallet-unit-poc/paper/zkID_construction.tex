% MOVED BELOW TO THE PRELIMS SECTION
% \subsection{High-Level Credential Issuance and Presentation Flow}\label{sec:high-level-flow}
%
% \begin{enumerate}
% \item The Prover receives a signed credential from an Issuer to be stored securely in their wallet, issued to the Wallet Secure Cryptographic Device (WSCD) public key.
% \item At presentation time, the Verifier sends over challenge $\texttt{nonce}_V$ for device-binding verification
% \item The Prover signs the challenge \texttt{nonce} with the public key $p_U$ controlled by their WSCD and specified in their credential
% \item The Prover computes two separate but linked zero-knowledge proofs $\pi_{\text{\texttt{prepare}}}, \pi_{\text{\texttt{show}}}$ which together cover the following statements: SD-JWT parsing, verification of the SD-JWT Issuer signature, 
% proper disclosures and/or arbitrary predicates on the disclosures, and device-binding 
% (i.e.\ checks the \texttt{nonce} signature against their public key); then sends $\pi_{\text{\texttt{prepare}}}, \pi_{\text{\texttt{show}}}$ to the Verifier.
% \item The Verifier verifies $\pi_{\text{\texttt{prepare}}}, \pi_{\text{\texttt{show}}}$ independently, and also verify that they are linked; grants Prover access to some service based on their credential disclosures.
% \end{enumerate}

\subsection{Pre-processing and linking proofs}
\label{ssec:preprocessing}

We split $C$ into two circuits that capture distinct relations about the credential: a \texttt{prepare} relation and a \texttt{show} relation (analogous to Microsoft’s Crescent Credentials \cite{cryptoeprint:2024/2013}). Proofs for \texttt{prepare} can be precomputed for any credential, since they are independent of the claims proved during presentation. Consequently, the online latency is dominated by the \texttt{show} relation.

A central requirement is the consistency of shared witnesses across these circuits (“linking”). Rather than the MAC-based technique of \cite{cryptoeprint:2024/2010}, the Prover sends Hyrax commitments to the witness components reused across circuits—namely, the raw messages $\{m_i\}$. The Verifier then compares these commitments across proofs to enforce equality of the underlying messages.

We highlight that the split is by phase rather than by field arithmetic. The \texttt{prepare} circuit necessarily includes wrong-field arithmetic (e.g., SHA-256 message hashes over a binary extension field and an ECDSA verification over a prime field), but this cost is amortized by precomputation. We prioritize (i) an efficient \texttt{show} relation and (ii) simple linking between \texttt{prepare} and \texttt{show}. Because equality of Hyrax commitments is checked within a single group, both relations use the same curve. In particular, we target a curve whose scalar field matches the base field of the device-binding signature (e.g., P-256) so that in-circuit verification is efficient and commitment equality checks are defined over the same group. Accordingly, we use Tom256 (T256), whose scalar field equals the base field of P-256.


We now detail each of the two (2) relations/circuits below.

\subsubsection{The \texttt{prepare} relation:}

The \texttt{prepare} relation checks the validity of issuer signature, parses the SD-JWT, and verifies all the message hashes, none of which depend on the specific presentation. 
Thus, the prover will periodically pre-compute and store a batch of re-randomized proofs of the prepare relation. 
These proofs will utilize Hyrax Pedersen vector commitments as introduced above in order to link the proofs of \texttt{prepare} relation to the \texttt{show}. 

\begin{mdframed}[style=zkprotocolwithheader, frametitle=Circuit $C_1$ for the \texttt{prepare} relation]

We define circuit $C(x = (PK_I), w_i = S, w = (\{m_i\}_{i=1}^N))$ as follows:

\begin{enumerate}
\item Assert $\text{parse}_{\text{SD-JWT}}(S) = (\{m_i\}, \{s_i\}, \{h_i\}_i, \sigma_I)$ parsing of the SD-JWT into messages $\{m_i\}_{i=1}^N$, message salts $\{s_i\}_{i=1}^N$, hashes $\{h_i\}_{i=1}^N$ and Issuer signature $\sigma_I$.
\item Assert $h_i = \text{SHA256}(m_i, s_i) \quad \forall i \in [n]$, i.e., \ that message hashes correspond to messages and salts
\item Assert $\text{ECDSA.verify}(\sigma_I, PK_I) = 1$, i.e., \ the credential signature verifies under the Issuer public key
\end{enumerate}

\end{mdframed}

The backend proving system we use for verifiably computing circuits is Spartan, coupled with a Hyrax-style Pedersen commitment scheme. 
We can express the circuit computation as some R1CS relation 
\[
(A \cdot Z) \circ (B \cdot Z) = (C \cdot Z),
\]
where $\vec{Z} = (io, 1, \vec{w})$ and $io$ are the public input/outputs. Spartan proves knowledge of a vector $Z$ of length $n := |Z|$ that satisfies the R1CS instance. 

To produce zkSNARK proofs for this circuit $C_1$, the prover will proceed in two phases:
\begin{enumerate}
\item \texttt{prepareCommit}: Separates out a column containing only message hashes $\{m_i\}_{i \in [N]}$ in $Z$ and computes an initial Hyrax commitment $c^{(1)} = \{c_i^{(1)}\}_{i \in [\sqrt{n}]}$, which includes a Pedersen commitment to the messages column $c_1^{(1)} = com(m_1, \dots, m_N; r_1^{(1)}) = g_1^{m_1} \dots g_N^{m_N} g_{N+1}^{r_1^{(1)}}$ with initial randomness $r_1^{(1)}$. 
\item \texttt{prepareBatch}: 
    \begin{enumerate}
        \item Re-randomizes this initial Hyrax commitment to get a batch of commitments $c^{(j)} = \{c_i^{(j)}\}_{i \in [\sqrt{n}]}$, each of which contains a Pedersen commitment to the messages $c_1^{(j)} = com_1^{(1)} \cdot g_{N+1}^{r_1^{(j)}-r_1^{(1)}}$ for all $j \in [m]$, 
        where our batch size $m$ depends on the frequency of proof generation and demand for the credential
        \item Continues the Spartan sumcheck IOP on each $c^{(j)}$ to produce a batch of proofs $\{\pi_{\texttt{prepare}}^{(j)}\}$ for $j \in [m]$ of the \texttt{prepare} relation.
    \end{enumerate}
\end{enumerate}
    
The prover will run \texttt{prepareBatch} periodically to both generate re-randomized commitments $c^{(j)}$ and store the randomness for the message column commitment $r_1^{(j)}$ for linking purposes, 
as well as generate and store batches of issuer-signature proofs $\pi_{\texttt{prepare}}^{(j)}$ that can be used for each presentation.

\subsubsection{The \texttt{show} relation:}

At a high level, our show relation will i) verifiably compute any functions $f_i$ over the SD-JWT messages (such as disclosures, range checks, etc.),
and ii) check that the credential belongs to the prover's device (also known as proof of ``device-binding''). 
As part of device-binding, the prover will sign a verifier \texttt{nonce} outside of the circuit.
Let us denote this signature by $\sigma_P = \sigma(\text{nonce}; SK_P)$

Again, we use T256 curve for our backend proving system so that the holder in-circuit signature verification can proceed naturally in the right field.

\begin{mdframed}[style=zkprotocolwithheader, frametitle=Circuit $C_2$ for the \texttt{show} relation]

We define circuit $C_2(x = (\{f_i\}_{i=1}^K, \{p_i\}_{i=1}^K), w = \{m_i\}_{i=1}^N)$ as follows:

\begin{enumerate}
\item Assert $p_i = f_i(m_1, \dots, m_n) \quad \forall i \in [n]$, i.e., correct evaluation of the predicates
\item Assert $\text{ECDSA.verify}(\sigma_{\text{nonce}}, m_1[1]) = 1$, i.e., that the live nonce signature corresponds to the public key the credential was issued to
\end{enumerate}

\end{mdframed}

As part of computing proof $\pi_{\texttt{show}}^{(j)}$ for presentation $j \in [m]$, 
the Prover will once again separate out the messages into a separate column to compute a Hyrax commitment over the Tom256 curve.
In particular, the Prover uses \textit{the same} randomness $r_1^{(j)}$ used during the \texttt{prepareBatch} process
to compute the Pedersen commitment to the messages column.
The verifier will then check that the Pedersen commitment to the messages column for $\pi_{\texttt{show}}^{(j)}$ equals that of proof $\pi_{\texttt{prepare}}^{(j)}$ for circuit $C_1$. 

\subsection{Adding ZK to Spartan}\label{subsec:adding-zk}

Our construction uses Circom in the frontend to compile our computation into an R1CS (instance, witness) pair $(x=(\mathbb{F}, A, B, C, io, n, m), \vec{w})$, 
which we then feed into the Spartan IOP coupled with Hyrax-style Pedersen polynomial commitments.

Recall that our R1CS constraint looks like the following:
$$
(A \cdot \vec{Z}) \circ (B \cdot \vec{Z}) - (C \cdot \vec{Z}) = 0
$$
where our square matrices $A, B, C$ have size $n$ and $\vec{Z} = (\vec{w}, 1, io)$.

Recall that Spartan converts an R1CS constraint into the following zero-check:
\begin{multline*}
\sum_{x \in \{0,1\}^{\log n}} \widetilde{eq}(x, \tau)\,
\bigg[
\bigg(\sum_{y \in \{0,1\}^{\log n}} \widetilde{A}(x,y)\,\widetilde{Z}(y)\bigg)
\bigg(\sum_{y \in \{0,1\}^{\log n}} \widetilde{B}(x,y)\,\widetilde{Z}(y)\bigg) \\
\qquad\qquad
- \bigg(\sum_{y \in \{0,1\}^{\log n}} \widetilde{C}(x,y)\,\widetilde{Z}(y)\bigg)
\bigg] \;=\; 0
\end{multline*}

for some random challenge $\tau \in \mathbb{F}$

We blind the evaluations of $z, a, b, c$ using random elements at the constraint system level. We insert into $z$ at the end of $r$ four random values to construct $z'$
$$z' = s \| p \| r \| (s_0, s_1, s_2, s_3) \| 1 \| x.$$

Then we insert three constraints into $A, B, C$ to construct modified matrices $A', B', C'.$ These constraints are
\begin{align}
    s_0 \times 0 &= 0 \\
    0 \times s_1 &= 0 \\
    s_2 \times 1 &= s_2
\end{align}

These force one random value into each of the MLEs for $a' = A' z'$ etc. In this way, the evaluations of $a'(\rho), b'(\rho), c'(\rho), z'(\rho)$ are independent of the witness $w$.

\subsubsection{Blinding Sumchecks}
To blind a sumcheck, we use the technique of Virgo. That is, for an $n$ round, degree $d$ sumcheck, we commit $n$ random univariate masking polynomials of degree $d,$ one for each round of the sumcheck. Then, given the evaluations we verify that the result of the sumcheck equals minus the evaluation is equal to an appropriate linear combination of the masking polynomial evaluations. 

The prover first commits to a sequence of $d$ values $\big( m_{i,x} \big)_{i \in [n], x \in \{ 0, 2..d\}}.$ Then in each round of the sumcheck, the prover will instead send
$$ \mathcal{P} \rightarrow \mathcal{V} : \big( m_{i,x} + f_i(x) \big)_{x \in \{0, 2..d\}}. $$

From which the verifier can interpolate the "blinded" $f'_i(X)$ and the blinded partial sum $\sigma'_i = f'_i(\alpha_i).$ Once again, we use $f'_i(1) = \sigma_{i-1} - f'_i(0)$ and $\sigma'_0 = \sigma_0.$

Then we replace the final consistency check with a zero knowledge proof $\pi$ of $m = \big( m_{i,x} \big)_{i \in [n], x \in \{0, 2..d\}}$ subject to the relation
$$ \mathcal{R} = \bigg\{ \big(\sigma'_n, F(\alpha) ; m \big) :\sigma'_n - F(\alpha) = \big\langle m, \ell(\alpha) \big\rangle \bigg\}. $$

We do this using a zero-knowledge IPA protocol. Note this is not hiding of the evaluation of $F(\alpha)$ or the sumcheck value $\sigma_0.$

\subsubsection{Security Analysis (Sketch) of zk-Spartan}
To show this protocol is zero-knowledge, we argue in three steps. First, we assume that the PCS and IPA protocols are zero-knowledge. Thus, it is sufficient to show that given both (blinded) sumcheck transcripts and the evaluations of the MLEs $a'(\alpha), b'(\alpha), c'(\alpha), z'(\alpha')$ we learn nothing about $w.$

The Simulator $\mathcal{S}$ first chooses any witness $z,$ a random $m$ vector, and random commitment $cm(m).$ This is possible because the IPA is zero knowledge. Then, $\mathcal{S}$ will choose uniformly random values for all $$\big( {f'_i}^{(\textsf{inner})}(x), {g'_j}^{(\textsf{outer})}(x) \big)_{i \in [n], j \in [m], x \in \{0, 2..d\}}$$ and for the evaluations $a'(\alpha), b'(\alpha), c'(\alpha).$ $\mathcal{S}$ will calculate the final witness opening as
$$ z'(\alpha') = \frac{\sigma_n' - \big\langle m, \ell(\alpha) \big\rangle}{A(\alpha, \alpha') + \chi B(\alpha, \alpha') + \chi^2 C(\alpha, \alpha')}. $$

Then, the verifier can solve a system of linear equations to find a unique $(s_0, s_1, s_2, s_3)$ and construct a random polynomial commitment for the opening of $z'$ to $z'(\alpha').$ This is because the polynomial commitment scheme is zero-knowledge.

Since the verifier performs one linear check, this yields a uniformly random valid transcript for the challenges $(\rho, \alpha, \chi, \alpha').$

\subsection{Security Analysis of OpenAC}
\label{ssec:security}

\paragraph{Correctness.}
The correctness follows immediately from the correctness of the Spartan SNARK and the fact that the Prover uses the same randomness for the Hyrax commitments across the \texttt{show} and \texttt{prepare} circuits for each presentation $i$.  

\paragraph{Soundness.}
The soundness of our protocol follows from the soundness of Spartan. In particular, we can extract the full witness credential from the \texttt{prepare} relation.

\paragraph{Zero-knowledge.}
Intuitively, zero-knowledge follows from the hiding property of the commitment scheme as well as the zero knowledge property of the Spartan zkSNARK proving system;
For proof $i$, simulator can randomly sample the linked commitment $com_i$ both distributions to reuse across both proofs, both in the commitment itself and also in the IPA used to open the Hyrax commitment to $Z(r_1, \dots, r_{\log{n}})$. 
We can show that this commitment is independent of the rest of the view of the Verifier, which consists of the following:

\begin{itemize}
    \item Sumcheck polynomials $\{s'_i(X)\}_{i \in [\log n]}$ for each of the sumchecks in Spartan
    \item $\{r_i\}$ Fiat-Shamir challenges during the sumcheck
    \item Transcript from the IPA on the sumcheck relation in ZK
    \item $\{com(z_i)\}_{i in [\sqrt{n}]}$ Hyrax commitment to $Z$, which involves a Pedersen commitment to each of the columns of a $\sqrt{n} \times \sqrt{n}$ matrix representation of $\vec{Z}$
    \item Transcript from the IPA for opening $Z(r_1, \dots, r_{\log n})$
    \item The claimed value of $Z(r_1, \dots, r_{\log n})$
\end{itemize}

Since we appended random pads to $\vec{Z}$ in our ZK modification in Section~\ref{subsec:adding-zk}, the distribution of $Z(r_1, \dots, r_{\log n})$ is random and independent of $Z$, and therefore independent of $\{m_i\}_i$.
Furthermore, $s'_i(X)$ have totally random pads on them and their distribution is independent of $Z$, and therefore independent of $\{m_i\}_i$.
Assuming the hiding property of the Pedersen commitment schemes for messages sent during an IPA, we can also use the simulators for the IPAs without changing their joint distribution with the rest of the transcript.
% i think this works: com (a, h(a)) ~ com (b, h(a)) ~ com (b, c) from hiding property that com(a) ~ com(b) for a =/= b.

Then, we can simply run the piece-wise simulators for each zkSNARK proof for circuits $C_1$ and $C_2$ to simulate the remainder of the view. 


% \begin{enumerate}
%     \item What are key techniques that will be used in our schemes?
%     \begin{itemize}
%         \item What are its inputs and outputs?
%         \item Participants and requirements of the techniques.
%     \end{itemize}
%     \item Describes the complete scheme, from preparation to verification. 
%     \begin{itemize}
%         \item The preliminaries of users when they use our system.
%         \item What is the difference between the preparation of this scheme and the traditional way?
%         \item Some questions we also answer here but just with a compact version, the detailed or proof will be shown in Security or Appendix section.
%         \begin{itemize}
%             \item Is it a dishonest majority setting or something else? 
%             \item What happens when the setting is broken?
%             \item What trust assumptions are our scheme based on?
%             \item Is this quantum-resistant? If not, is it upgradable to quantum-resistant?
%             \item The correctness, soundness, and zk.
%         \end{itemize}
%     \end{itemize}
%     \item Discuss about the compatibility of our system when upgrading from an older system.
%     \begin{enumerate}
%         \item What happens with the older system?
%         \begin{itemize}
%             \item Is it required to change the issuance process? 
%             \item Is it a breaking change or just a soft update?
%             \item What happens with the issued ID, can it be re-used, and re-issued with a new scheme?
%             % should be revoked
%             \item \textbf{It depends on the answer about the final construction. But we have some design constraints that should be followed, which are described in slide 111 of \href{https://docs.google.com/presentation/d/1C4D8zK4gAdafgIEW-2m_qDyyT39gWo0mmFYpwmA8N3M/edit?slide=id.g338a079cb64_0_31\#slide=id.g338a079cb64_0_31}{this doc}} 
%         \end{itemize} 
%         \item What about the new PID?
%         \begin{enumerate}
%             \item What is the difference between the PID of the new scheme and the current version? Is it added more data fields to the current struct?
%             \item If not, is the process from PID to scheme input straightforward (and provable?)?
% % \textbf{            \item What if the Issuer or the ID owner wants to revoke some IDs, does it require the Issuer to update frequently? -- still need to add this}            \item If the Issuer needs to update frequently, what if they are disconnected for a while? 
%             \item What is the trust assumption?
%         \end{enumerate}
%     \end{enumerate}
%     \item After show the detailed construction, we will show more detailed about why our construction should be considered with some detailed.
%     \begin{enumerate}
%         \item What are the main advantages that make zkID outperform other solutions? 
%             \item TODO: wait for benchmarks from the technical team 
%         \item What are the trade-offs if users take our advancement?
%     \end{enumerate}
% \end{enumerate}